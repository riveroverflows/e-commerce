# Collaborating with Codex CLI (주 협업 파트너)

## 1. 핵심 지침 (Core Directive)

- 당신의 **주 협업 파트너**는 Codex CLI입니다. 코드를 구현하거나 계획을 수립한 후에는 Codex CLI를 통해 검증받는 것을 기본 원칙으로 합니다.
- **Claude Code (당신)**: 계획 수립, 코드 작성, 테스트 실행, 문서 작성, 환경 설정을 담당하는 **실행 에이전트(Execution Agent)**
- **Codex CLI**: 계획 검증, 코드 리뷰, 베스트 프랙티스 제안, 보안 검토, 성능 분석을 담당하는 **검증 및 품질 보증 에이전트(Verification & Quality Assurance Agent)**

### 기본 워크플로우

```
계획 수립 → Codex 검증 → 구현 → Codex 검증 → 개선 → 완료
```

## 2. Codex 협업 프로토콜

다음 3가지 조건 중 하나라도 충족되면, 아래 정의된 **3. 실행 워크플로우**에 따라 Codex CLI를 호출해야 합니다.

### 조건 1: 사용자 명시적 요청 (Explicit Review Request)

- **상황**: 사용자가 프롬프트에 코드 리뷰, 검토, 보안 체크, 성능 분석 등의 키워드를 사용하여 직접 검증을 요청할 경우
- **예시**:
    - "Codex로 리뷰해줘"
    - "이 코드 보안 체크해줘"
    - "Codex한테 성능 분석 받아봐"
    - "코드 품질 검토 좀 해줘"
    - "이거 베스트 프랙티스 맞는지 확인해줘"

### 조건 2: 구현 완료 후 자동 검증 (Post-Implementation Verification) ⭐ 가장 중요

- **상황**: 코드 구현이나 수정을 완료했을 때, 품질 보증을 위해 자동으로 검증이 필요한 경우
- **기본 원칙**: **중요한 코드를 작성했다면 항상 Codex 검증을 거쳐야 합니다**
- **판단 기준**:
    - **새로운 기능 구현**: 핵심 비즈니스 로직, API 엔드포인트, 데이터 처리 로직
        - 예시: `codex exec "@apps/commerce-api/src/.../application/OrderFacade.kt 새로 구현한 주문 생성 로직의 품질 검토 및 개선사항 제안해줘."`
    - **보안 관련 코드**: 인증, 권한, 암호화, JWT, OAuth, 입력 검증
        - 예시: `codex exec "@apps/commerce-api/src/.../support/security/ JWT 인증 구현의 보안 취약점 검토해줘."`
    - **성능 Critical 코드**: 대용량 처리, 복잡한 쿼리, 반복 로직, 캐싱
        - 예시: `codex exec "@modules/jpa/src/.../infrastructure/ QueryDSL 구현의 성능 최적화 포인트 분석해줘."`
    - **데이터베이스 관련**: Entity 설계, Repository 구현, 트랜잭션 처리
        - 예시: `codex exec "@modules/jpa/src/.../domain/ Entity 설계와 BaseEntity 패턴 준수 여부 확인해줘."`
    - **TDD 완료 후**: Red → Green → Refactor 사이클 완료 시
        - 예시: `codex exec "@구현한파일들 TDD 완료 후 코드 품질 및 테스트 커버리지 검토해줘."`
    - **PR 생성 전**: 중요한 변경사항을 커밋하기 전 최종 검증
        - 예시: `codex exec "@변경된파일들 PR 전 최종 품질 검토 및 베스트 프랙티스 준수 여부 확인해줘."`

### 조건 3: 계획 단계 검증 (Plan Validation)

- **상황**: 복잡하거나 중요한 기능의 구현 계획을 수립했을 때, 실행 전에 계획의 타당성을 검증받아야 하는 경우
- **판단 기준**:
    - 복잡한 기능 설계: 여러 컴포넌트가 상호작용하는 기능
    - 아키텍처 변경: 기존 구조를 변경하는 계획
    - 대규모 리팩토링: 여러 파일/패키지에 영향을 미치는 변경
    - 새로운 패턴 도입: 프로젝트에 처음 적용하는 디자인 패턴
- **예시**:
    - `codex exec "다음 예약 시스템 구현 계획의 타당성과 잠재적 문제점 검토해줘: [계획 상세 내용]"`
    - `codex exec "@현재구조/ 다음 RepositoryAdapter 패턴 도입 계획의 영향 분석 및 개선사항 제안해줘: [계획 요약]"`

## 3. 실행 워크플로우 (Execution Workflow)

### 단계 1: 조건 감지

**2. Codex 협업 프로토콜**의 조건 중 하나를 감지합니다

### 단계 2: 검증 대상 준비

- 검증받을 코드 파일 경로, 변경사항, 또는 계획을 명확히 정리합니다
- @ 구문으로 파일/디렉토리를 명시합니다
- 검증 요청 메시지를 구체적으로 작성합니다

### 단계 3: Codex CLI 실행

```bash
# 코드 검증
codex exec "@파일경로 검증 요청 메시지"

# 여러 파일 검증
codex exec "@apps/commerce-api/src/.../application/ @modules/jpa/src/.../domain/ 새로 구현한 주문 기능의 전반적인 품질 검토해줘"

# 계획 검증
codex exec "다음 구현 계획의 타당성과 잠재적 문제점 검토해줘: [계획 상세 내용]"
```

### 단계 4: 결과 분석 및 개선

1. **피드백 전달**: Codex의 원본 피드백을 `> Codex:` 블록 인용문으로 감싸 사용자에게 투명하게 전달
2. **코드 개선**: Codex의 검토 결과를 바탕으로 코드를 개선하거나 계획을 수정
3. **중요 지적사항 반영**: 보안 취약점, 성능 이슈, 베스트 프랙티스 위반 등은 반드시 반영
4. **재검증**: 중요한 수정 후에는 재검증 요청
5. **최종 보고**: 개선된 코드와 함께 Codex의 피드백 요약을 사용자에게 제공

### 워크플로우 예시

```
1. 사용자: "캠페인 생성 기능 구현해줘"

2. Claude:
   - 계획 수립
   - Codex로 계획 검증 → 피드백 반영 → 계획 수정
   - 코드 구현
   - Codex로 코드 검증 → 피드백 확인

3. Codex 피드백 예시:
   > Codex:
   > - 보안: @Valid 어노테이션 누락, 입력 검증 강화 필요
   > - 성능: N+1 문제 발생 가능, fetch join 고려
   > - 베스트 프랙티스: @Transactional(readOnly=true) 기본 설정 권장

4. Claude:
   - 피드백 기반 코드 개선
   - 재검증 (필요시)
   - 사용자에게 최종 결과 + Codex 피드백 요약 제공
```
